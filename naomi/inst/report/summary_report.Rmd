---
title: "&nbsp;"
fig_width: 5
fig_height: 5
params:
  output_zip: NA
  spectrum_file: NA
  options: NA
  lang: NA
output:
  html_document:
    css: styles.css
    includes:
      in_header: header.html
    anchor_sections: false
---

```{r, include = FALSE}
if (params$lang == "fr") {
  print_en <- FALSE
  print_fr <- TRUE
} else {
  print_en <- TRUE
  print_fr <- FALSE
}
```

```{r read_outputs, echo=FALSE, message = FALSE, warning = FALSE}
#Set limit for scientific notation
options(scipen=10000000)

# Read in files from naomi outputs zip
output_zip <- params$output_zip

outputs <- naomi::read_output_package(output_zip)
inputs <- unz(output_zip, "info/inputs.csv") 
inputs <- read.csv(inputs)
options <- unz(output_zip, "info/options.yml")
options <- yaml::read_yaml(options)

indicators <- naomi::add_output_labels(outputs) %>%
  dplyr::left_join(
           outputs$meta_area %>%
           dplyr::select(area_level, area_id, center_x, center_y), 
           by = c("area_level", "area_id")
         ) %>%
  sf::st_as_sf()

# Grab inputs and model options from model output zip file
# # concatenating strings where more than one option may be selected
report_date <- format(Sys.Date(), "%d-%m-%Y")
t1 <- options$calendar_quarter_t1
t2 <- options$calendar_quarter_t2
iso <- options$area_scope
quarter_t1 <- outputs$meta_period[outputs$meta_period$calendar_quarter == t1,]$quarter_label
quarter_t2 <- outputs$meta_period[outputs$meta_period$calendar_quarter == t2,]$quarter_label
level <- as.integer(options$area_level)
survey_prev <- paste0(options$survey_prevalence, collapse = ", ")
survey_art <- paste0(options$survey_art_coverage, collapse = ", ")
survey_recent <- paste0(options$survey_recently_infected, collapse = ", ")
spectrum_file <- paste0(inputs[inputs$role == "pjnz",]$filename)


# Determine if and when programme data has been included 
include <- tibble::tibble(
  art = list(options$include_art_t1, options$include_art_t2),
  art_year = list(quarter_t1, quarter_t2),
  art_attend = list(options$artattend, options$artattend_t2)
) %>%
  dplyr::mutate_all(list(~dplyr::na_if(., "NULL"))) %>%
  dplyr::mutate_all(list(~dplyr::na_if(., "")))

# Select years where ART programme data is included
collapse_and <- " and "
if (print_fr) {
  collapse_and <- " et "
}

if("true" %in% include$art) {
  df <- include %>% dplyr::filter(art == "true")
  art_year <- paste0(df$art_year, sep = "", collapse = collapse_and)
} else {
  art_year <- NA
}

# Select years where ART attendance reallocation is implemented
if("true" %in% include$art_attend ) {
  df <- include %>% dplyr::filter(art_attend == "true")
  art_attend <- paste0(df$art_year, sep = "", collapse = collapse_and)
} else {
  art_attend <- NA
}

# Select years where ANC ART programme data is included
anc_art_options = list(options$anc_art_coverage_year1, options$anc_art_coverage_year2) 
anc_art_options <- anc_art_options[!sapply(anc_art_options,is.null)]

if(length(anc_art_options)) {
  anc_art <- paste0(anc_art_options, sep = "", collapse = collapse_and)
} else {
  anc_art <- NA
}

# Select years where ANC prev programme data is included
anc_prev_options = list(options$anc_prevalence_year1,options$anc_prevalence_year2)
anc_prev_options <- anc_art_options[!sapply(anc_art_options,is.null)]

if(length(anc_prev_options)) {
  anc_prev <- paste0(anc_prev_options, sep = "", collapse = collapse_and)
} else {
  anc_prev <- NA
}


# Identify area_level_label for model estimates
area_level_map <- outputs$meta_area %>%
  dplyr::group_by(area_level, area_level_label) %>%
  dplyr::summarise(.groups = "drop")

area_level_label <- area_level_map$area_level_label[area_level_map$area_level == level]
country <- paste0(outputs$meta_area$area_name[outputs$meta_area$area_id == iso],
                  sep = "", collapse = "")


# Filter data for area + calendar options selected in model run 
data <- dplyr::filter(indicators, 
                      area_level == level, 
                      calendar_quarter == t2)

# Determine number of districts in lowest area level
district_count <- length(levels(as.factor(data$area_name)))

# Legend functions
#-------------------------------------------------------------------------------
# Map Figure
#-------------------------------------------------------------------------------
map_outputs <- function(geom_data,
                        var,
                        age, 
                        sex_disag,
                        start_colour_scale, 
                        end_colour_scale, 
                        legend_title, 
                        legend_label = ggplot2::waiver(), 
                        fig_title) {
  
  # filter data for desired indicator
  fig_data <- geom_data %>% dplyr::filter(indicator == var, 
                                          age_group == age,
                                          sex == sex_disag)
  # generate figure
  ggplot2::ggplot(fig_data, ggplot2::aes(fill = mean)) +
    ggplot2::geom_sf() +
    ggplot2::coord_sf(datum = NA) +
    ggplot2::scale_fill_gradient(low = start_colour_scale,
                                 high = end_colour_scale,
                                 name = legend_title,
                                 guide = "legend", 
                                 labels = legend_label) +
    ggplot2::theme_bw() +
    ggplot2::theme(legend.position = "bottom",
                   legend.direction = "vertical", 
                   plot.title = ggplot2::element_text(size = 8, face = "bold"), 
                   legend.text = ggplot2::element_text(size = 8), 
                   legend.title = ggplot2::element_text(size = 8, face = "bold", hjust = 0.5),
                   legend.key.size = ggplot2::unit(0.7, "lines"),
                   legend.background = ggplot2::element_rect(linetype = "dashed",
                                                             colour = "black"),
                   legend.title.align = 0.5, 
                   plot.margin = ggplot2::margin(0, 0.4, 0, 0.4, "cm")) +
    ggplot2::ggtitle(fig_title)
}

#-------------------------------------------------------------------------------
# Pop pyramid
#-------------------------------------------------------------------------------

pop_pyramid_outputs <- function(disag_data,
                                var,
                                left_colour, 
                                right_colour, 
                                x_axis_title, 
                                legend_label = abs, 
                                fig_title, 
                                lang = "en") {
  
  ## Graph formatting based on langauge (default is english)
  if(lang == "fr" ){
    masc <- "hommes"
    fem <- "femmes"
    y_title <- "groupe d'Ã¢ge"
    
    dat <- disag_data %>%
      dplyr::mutate(
        sex = dplyr::case_when(
          sex == "male" ~ "hommes", 
          sex == "female" ~ "femmes"))
    
    cols <- c("hommes" = left_colour, 
              "femmes" = right_colour)
    
  } else {
    masc <- "male"
    fem <- "female"
    y_title <- "Age Group"
    
    dat <- disag_data 
    
    cols <- c("male" = left_colour, 
              "female" = right_colour)
  }
  
  
  ## filter data for desired indicator
  fig_data <- dat %>%
    dplyr::filter(indicator == var)
  
  plot <- ggplot2::ggplot(fig_data, ggplot2::aes(x = ifelse(sex == masc, -mean, mean),
                                                 y = age_group,
                                                 ymin = lower,
                                                 ymax = upper,
                                                 fill = sex)) +
    ggplot2::geom_col(width = 0.85) +
    ggplot2::scale_x_continuous(labels = legend_label,
                                limits = max(fig_data$mean) * c(-1,1)) +
    ggplot2::labs(x = x_axis_title) +
    ggplot2::scale_fill_manual(values = cols) +
    ggplot2::theme_classic(base_size = 10) +
    ggplot2::theme(legend.position = "top", 
                   plot.title = ggplot2::element_text(size = 8, face = "bold",
                                             hjust = 0.5),
                   axis.title = ggplot2::element_text(size = 6), 
                   axis.text.x = ggplot2::element_text(size = 5),
                   axis.text.y = ggplot2::element_text(size = 5),
                   legend.title = ggplot2::element_blank(),
                   legend.text = ggplot2::element_text(size = 6), 
                   legend.key.size = ggplot2::unit(0.5, "lines"),
                   plot.margin = ggplot2::margin(0.5, 0.3, 0.5, 0.3, "cm")) +
    ggplot2::ylab(y_title) +
    ggplot2::ggtitle(fig_title)
}

#-------------------------------------------------------------------------------
# District Barplot + National indicator
#-------------------------------------------------------------------------------
  
 national_district_bar_plot <- function(district_data, 
                               var, 
                               age_disag, 
                               sex_disag = "both",
                               national_indicator,
                               label_format,
                               x_axis_title, 
                               fig_title, 
                               lang = "en") {
   
   ## Graph formatting based on langauge (default is english)
   if(lang == "fr") {
     above <- "au-dessus"
     below <- "en dessous"
   } else {
     above <- "above"
     below <- "below"
   }
   
  
   # Filter data for desired indicator and disag
   # # assign categories based on national level indicator 
   fig_data <- data %>% sf::st_drop_geometry() %>%
     dplyr::filter(indicator == var, 
                   age_group == age_disag,
                   sex == sex_disag, 
     )%>%
     dplyr::mutate(threshold = ifelse(mean > national_indicator,above, below),
                   threshold = as.factor(threshold))
   
   #Plot figure
   ggplot2::ggplot(fig_data, ggplot2::aes(reorder(area_name, mean),
                                                mean,
                                                ymin = lower,
                                                ymax = upper,
                                                fill = threshold)) +
     ggplot2::theme_classic() +
     ggplot2::geom_col(position = "dodge") +
     ggplot2::geom_linerange(position = ggplot2::position_dodge(0.8)) +
     ggplot2::scale_y_continuous(labels = label_format) +
     ggplot2::theme(
       axis.text.x = ggplot2::element_text(size = 8),
       legend.background = ggplot2::element_rect(linetype = "dashed", colour = "black"),
       legend.text = ggplot2::element_text(size = 8), 
       legend.position = "bottom",
       legend.direction = "vertical", 
       legend.title = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.x = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.y = ggplot2::element_blank()) +
     ggplot2::ylab(x_axis_title) +
     ggplot2::geom_hline(yintercept= national_indicator, linetype="dashed", color = "black")+
     
     ggplot2::ggtitle(fig_title) + 
     ggplot2::coord_flip()
   
 }

#------------------------------------------------------------------------------- 
# District Barplot (no national indicator)
#-------------------------------------------------------------------------------  
district_bar_plot <- function(district_data, 
                              var, 
                              age_disag, 
                              colour,
                              sex_disag = "both",
                              label_format,
                              x_axis_title, 
                              fig_title) {
   
   # Filter data for desired indicator and disag
   # # assign categories based on national level indicator 
   fig_data <- data %>% sf::st_drop_geometry() %>%
     dplyr::filter(indicator == var, 
                   age_group == age_disag,
                   sex == sex_disag)
   
   #Plot figure
   ggplot2::ggplot(fig_data, ggplot2::aes(reorder(area_name, mean),
                                                mean,
                                                ymin = lower,
                                                ymax = upper)) +
     ggplot2::theme_classic() +
     ggplot2::geom_col(position = "dodge", fill = colour) +
     ggplot2::geom_linerange(position = ggplot2::position_dodge(0.8)) +
     ggplot2::scale_y_continuous(labels = label_format) +
     ggplot2::theme(
       plot.title = ggplot2::element_text(size = 10),
       axis.text.x = ggplot2::element_text(size = 8),
       axis.title.x = ggplot2::element_text(size = 8, face = "bold"), 
       axis.title.y = ggplot2::element_blank()) +
     ggplot2::ylab(x_axis_title) +
     ggplot2::ggtitle(fig_title) + 
     ggplot2::coord_flip()
   
 }
 
```


```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

cat(paste0("# ", country, " Subnational HIV Estimates \n"))

cat(paste0("### **", quarter_t2, "** (report ", report_date, ")"))
```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

cat(paste0("# ", country, " Estimations infranationales du VIH \n"))

cat(paste0("### **", quarter_t2, "** (rapport ", report_date, ")"))
```


``` {r, echo = FALSE, results = 'asis', include = print_en, eval = print_fr}
cat(paste0("This report summarises the **", area_level_label, "-level** HIV indicators for **", country,"** from the Naomi model", sep = "\n"))
```

``` {r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
cat(paste0("Ce rapport rÃ©sume les **", area_level_label, "** indicateurs VIH pour **", country,"** du modÃ¨le Naomi", sep = "\n"))
```


```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

cat("Naomi is a statistical model that uses data from several sources, including:  \n")

cat("\nNational survey data:   \n")

```


```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

cat("Naomi est un modÃ¨le statistique qui utilise des donnÃ©es provenant de plusieurs sources, notamment:  \n")

cat("\nDonnÃ©es d'enquÃªte nationale:   \n")

```


```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}
text1 <- tibble::tibble(prefix = c("National household survey data on new HIV infections from ",
                                   "National household survey data on HIV prevalence from ",
                                   "National household survey data on ART coverage from "), 
                        source = c(survey_recent,
                                   survey_prev,
                                   survey_art)) %>%
  dplyr::filter(source != "")


cat(paste0("* ", text1$prefix, "_", text1$source, "_"), sep = "\n")
```
  
```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
text1 <- tibble::tibble(prefix = c("DonnÃ©es d'enquÃªte nationale auprÃ¨s des mÃ©nages sur les nouvelles infections Ã  VIH de ",
                                   "DonnÃ©es dâenquÃªte nationale auprÃ¨s des mÃ©nages sur la prÃ©valence du VIH de ",
                                   "DonnÃ©es dâenquÃªte nationale auprÃ¨s des mÃ©nages sur la couverture du TAR auprÃ¨s de "), 
                        source = c(survey_recent,
                                   survey_prev,
                                   survey_art)) %>%
  dplyr::filter(source != "")


cat(paste0("* ", text1$prefix, "_", text1$source, "_"), sep = "\n")
```
  
  
```{r, echo = FALSE, results= 'asis', include = print_fr, eval = print_fr}
programme_data <- c(art_year, anc_prev, anc_art)

if(sum(is.na(programme_data)) <3 ) {
  
  cat(paste0("\n DonnÃ©es du programme opÃ©rationnel: \n", sep = "\n"))
  
  text2 <- tibble::tibble(prefix = c("DonnÃ©es national sur la couverture TARV pour ",
                                  "DonnÃ©es national sur la prÃ©valence du VIH parmi CPN pour ", 
                                  "DonnÃ©es national sur la couverture du TARV parmi CPN pour "
                                  ), 
                       source = c(art_year,
                                  anc_prev, 
                                  anc_art)) %>%
  tidyr::drop_na()


cat(paste0("\n ",cat(paste0("* ", text2$prefix, "_", text2$source, "_"), sep = "\n")))
  
}

 cat(paste0("\n et estimations nationales du VIH Ã  partir du fichier Spectrum _", spectrum_file,"_",
           "\n Ã  l'aide des options d'Ã©talonnage: \n " ))
```

  
```{r, echo = FALSE, results= 'asis', include = print_en, eval = print_en}
programme_data <- c(art_year, anc_prev, anc_art)

if(sum(is.na(programme_data)) <3 ) {
  
  cat(paste0("\n Operational programme data: \n", sep = "\n"))
  
  text2 <- tibble::tibble(prefix = c("National programme data on ART coverage for ",
                                  "National programme data on ANC HIV prevalence for ", 
                                  "National programme data on ANC ART coverage for "
                                  ), 
                       source = c(art_year,
                                  anc_prev, 
                                  anc_art)) %>%
  tidyr::drop_na()


cat(paste0("\n ",cat(paste0("* ", text2$prefix, "_", text2$source, "_"), sep = "\n")))
  
}

 cat(paste0("\n and national HIV estimates from Spectrum file _", spectrum_file,"_",
           "\n using calibration options: \n " ))
```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

# Read in calibration options from calibration_options.yml, if that does not exist, 
# use default options in options.yml
calibration_files <- utils::unzip(output_zip, list = TRUE)

if("info/calibration_options.yml" %in% calibration_files$Name) {
  calibration_options <- unz(output_zip, "info/calibration_options.yml")
  calibration_options <- yaml::read_yaml(calibration_options)
} else {
  calibration_options <- options[grep("calibration", names(options))]
}

# Translate calibration options to human readable
calibration_options <- get_calibration_option_labels(calibration_options)

text <- tibble::tibble(prefix = c("Population calibration: ",
                                  "PLHIV calibration level: ", 
                                  "PLHIV calibration strata: ",
                                  "Status known calibration level: ",
                                  "Status known calibration strata: ",
                                  "ART number calibration level: ", 
                                  "ART number calibration strata: ", 
                                  "New infections calibration level: ",
                                  "New infections calibration strata: "
                                  ), 
                       source = c(options$spectrum_population_calibration,
                                  calibration_options$spectrum_plhiv_calibration_level,
                                  calibration_options$spectrum_plhiv_calibration_strat,
                                  calibration_options$spectrum_aware_calibration_level,
                                  calibration_options$spectrum_aware_calibration_strat,
                                  calibration_options$spectrum_artnum_calibration_level,
                                  calibration_options$spectrum_artnum_calibration_strat, 
                                  calibration_options$spectrum_infections_calibration_level,
                                  calibration_options$spectrum_infections_calibration_strat
                                  ))

# Add calibration method in if present in calibration options
if("calibrate_method" %in% names(calibration_options)) {
  
  add <- tibble::tibble(prefix ="Calibration method: ", 
                        source = calibration_options$calibrate_method )
  text <- rbind(text, add)
}
  
# Filter out strata options if calibration not selected
if(text$source[text$prefix == "PLHIV calibration level: "] == "None"){
  text <- dplyr::filter(text, !grepl("PLHIV", prefix))
}

if(text$source[text$prefix == "Status known calibration level: "] == "None"){
  text <- dplyr::filter(text, !grepl("Status",prefix))
  }

if(text$source[text$prefix == "ART number calibration level: "] == "None"){
  text <- dplyr::filter(text, !grepl("ART",prefix))
  }

if(text$source[text$prefix == "New infections calibration level: "] == "None"){
  text <- dplyr::filter(text, !grepl("infections",prefix))
  }

if(nrow(text) > 0) {
  cat(paste0("* ", text$prefix, "_", text$source, "_"), sep = "\n")
} else {
  cat(paste0("* No calibration selected"), sep = "\n")
}
```


```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

# Read in calibration options from calibration_options.yml, if that does not exist, 
# use default options in options.yml
calibration_files <- utils::unzip(output_zip, list = TRUE)

if("info/calibration_options.yml" %in% calibration_files$Name) {
  calibration_options <- unz(output_zip, "info/calibration_options.yml")
  calibration_options <- yaml::read_yaml(calibration_options)
} else {
  calibration_options <- options[grep("calibration", names(options))]
}

# Translate calibration options to human readable
calibration_options <- get_calibration_option_labels(calibration_options)

text <- tibble::tibble(prefix = c("Ãtalonnage de la population: ",
                                  "Niveau d'Ã©talonnage des PVVIH: ", 
                                  "Strates d'Ã©talonnage des PVVIH: ",
                                  "Ãtat du niveau d'Ã©talonnage connu: ",
                                  "Ãtat des strates d'Ã©talonnage connues: ",
                                  "Niveau d'Ã©talonnage du numÃ©ro TARV: ", 
                                  "Strates d'Ã©talonnage du numÃ©ro TARV: ", 
                                  "Nouveau niveau d'Ã©talonnage des infections: ",
                                  "Nouvelles strates d'Ã©talonnage des infections: "
                                  ), 
                       source = c(options$spectrum_population_calibration,
                                  calibration_options$spectrum_plhiv_calibration_level,
                                  calibration_options$spectrum_plhiv_calibration_strat,
                                  calibration_options$spectrum_aware_calibration_level,
                                  calibration_options$spectrum_aware_calibration_strat,
                                  calibration_options$spectrum_artnum_calibration_level,
                                  calibration_options$spectrum_artnum_calibration_strat, 
                                  calibration_options$spectrum_infections_calibration_level,
                                  calibration_options$spectrum_infections_calibration_strat
                                  ))

                                  

# Add calibration method in if present in calibration options
if("calibrate_method" %in% names(calibration_options)) {
  
  add <- tibble::tibble(prefix ="MÃ©thode d'Ã©talonnage: ", 
                        source = calibration_options$calibrate_method )
  text <- rbind(text, add)
}
  
# Filter out strata options if calibration not selected
if(text$source[text$prefix == "Niveau d'Ã©talonnage des PVVIH: "] == "None"){
  text <- dplyr::filter(text, !grepl("PVVIH", prefix))
}

if(text$source[text$prefix == "Ãtat du niveau d'Ã©talonnage connu: "] == "None"){
  text <- dplyr::filter(text, !grepl("Ãtat",prefix))
  }

if(text$source[text$prefix == "Niveau d'Ã©talonnage du numÃ©ro TARV: "] == "None"){
  text <- dplyr::filter(text, !grepl("TARV",prefix))
  }

if(text$source[text$prefix == "Nouveau niveau d'Ã©talonnage des infections: "] == "None"){
  text <- dplyr::filter(text, !grepl("infections",prefix))
  }

if(nrow(text) > 0) {
  cat(paste0("* ", text$prefix, "_", text$source, "_"), sep = "\n")
} else {
  cat(paste0("* Aucun Ã©talonnage sÃ©lectionnÃ©"), sep = "\n")
}
```


```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}
if("true" %in% include$art_attend) {
  
  cat(paste0("ART coverage is estimated accounting for patient mobility between
             neighbouring districts (for ", art_attend, "). 
             \n Further technical information about this allocation method
             and the Naomi model is available at the end of this report."))
} else {
  
  cat(paste0("Further technical information about the Naomi model is available 
             at the end of this report."))
}

```


```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
if("true" %in% include$art_attend) {
  
  cat(paste0("La couverture du ART est estimÃ©e en tenant compte de la mobilitÃ© 
  des patients entre les districts voisins (pour ", art_attend, "). 
             \n De plus amples informations techniques sur cette mÃ©thode 
  d'allocation et le modÃ¨le Naomi sont disponibles Ã  la fin de ce rapport."))
} else {
  
  cat(paste0("De plus amples informations techniques sur cette mÃ©thode 
             d'allocation et le modÃ¨le Naomi sont disponibles Ã  la fin de ce rapport."))
}

```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

cat("### **Geographic distribution of PLHIV**")

```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

cat("### **RÃ©partition gÃ©ographique des PVVIH**")

```

```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", results = 'asis', include = print_fr, eval = print_fr}

#-------------------------------------------------------------------------------
# Map: PLHIV (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p1 <- map_outputs(geom_data = data, 
                  var = "plhiv",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#FFE3E00F", 
                  end_colour_scale = "red4", 
                  fig_title = "Personnes vivant avec le VIH\n (15 ans et plus)",
                  legend_title = "PVVIH")

#-------------------------------------------------------------------------------
# Map: on ART
# # By lowest area_level
#-------------------------------------------------------------------------------
p2 <- map_outputs(geom_data = data, 
                  var = "art_current_residents",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#C3CFC30F", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "RÃ©sidents recevant TARV (15+)",
                  legend_title = "Nombre de personnes sous TARV"
)

#-------------------------------------------------------------------------------
# Map: new infections (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p3 <- map_outputs(geom_data = data, 
                  var = "infections",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#7181910F", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Infections annuelles au VIH (15+)",
                  legend_title = "Infections" )


grid::grid.draw(cbind(ggplot2::ggplotGrob(p1), ggplot2::ggplotGrob(p2), 
                      ggplot2::ggplotGrob(p3)))

```

```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", results = 'asis', include = print_en, eval = print_en}

#-------------------------------------------------------------------------------
# Map: PLHIV (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p1 <- map_outputs(geom_data = data, 
                  var = "plhiv",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#FFE3E00F", 
                  end_colour_scale = "red4", 
                  fig_title = "People living with HIV (15+)",
                  legend_title = "PLHIV")


#-------------------------------------------------------------------------------
# Map: on ART
# # By lowest area_level
#-------------------------------------------------------------------------------
p2 <- map_outputs(geom_data = data, 
                  var = "art_current_residents",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#C3CFC30F", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "Residents receiving ART (15+)",
                  legend_title = "Number on ART"
)

#-------------------------------------------------------------------------------
# Map: new infections (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p3 <- map_outputs(geom_data = data, 
                  var = "infections",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#7181910F", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Annual HIV infections (15+)",
                  legend_title = "Infections" )


grid::grid.draw(cbind(ggplot2::ggplotGrob(p1), ggplot2::ggplotGrob(p2), 
                      ggplot2::ggplotGrob(p3)))

```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

cat("### **Geographic distribution of rates of HIV infection**")

```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

cat("### **RÃ©partition gÃ©ographique des taux d'infection par le VIH**")

```


```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", out.height=  "100%", results = 'asis', include = print_en, eval = print_en}

#-------------------------------------------------------------------------------
# Map: Prevalence (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p4 <- map_outputs(geom_data = data, 
                  var = "prevalence",
                  age = "Y015_049", 
                  sex_disag = "both", 
                  start_colour_scale = "#FFE3E00F", 
                  end_colour_scale = "red4", 
                  fig_title = "HIV prevalence (15-49)",
                  legend_title = "Prevalence", 
                  legend_label = scales::percent_format())

#-------------------------------------------------------------------------------
# Map: ART coverage (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p5 <- map_outputs(geom_data = data, 
                  var = "art_coverage",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#C3CFC30F", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "Proportion PLHIV on ART (15+)",
                  legend_title = "ART Coverage", 
                  legend_label = scales::percent_format(accuracy = 5L)
)

#-------------------------------------------------------------------------------
# Map: Incidence
# # By lowest area_level
#-------------------------------------------------------------------------------
p6 <- map_outputs(geom_data = data, 
                  var = "incidence",
                  age = "Y015_049", 
                  sex_disag = "both", 
                  start_colour_scale = "#7181910F", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Rate of HIV infection (15-49)",
                  legend_title = "Incidence per 1000", 
                  legend_label = scales::label_number(0.1, 1000)
)

grid::grid.draw(cbind(ggplot2::ggplotGrob(p4), ggplot2::ggplotGrob(p5), 
                      ggplot2::ggplotGrob(p6)))

```



```{r, echo=FALSE,warning = FALSE, out.width  =  "75%", out.height=  "100%", results = 'asis', include = print_fr, eval = print_fr}

#-------------------------------------------------------------------------------
# Map: Prevalence (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p4 <- map_outputs(geom_data = data, 
                  var = "prevalence",
                  age = "Y015_049", 
                  sex_disag = "both", 
                  start_colour_scale = "#FFE3E00F", 
                  end_colour_scale = "red4", 
                  fig_title = "PrÃ©valence du VIH (15-49)",
                  legend_title = "PrÃ©valence", 
                  legend_label = scales::percent_format())

#-------------------------------------------------------------------------------
# Map: ART coverage (mean)
# # By lowest area_level
#-------------------------------------------------------------------------------
p5 <- map_outputs(geom_data = data, 
                  var = "art_coverage",
                  age = "Y015_999", 
                  sex_disag = "both", 
                  start_colour_scale = "#C3CFC30F", 
                  end_colour_scale = "olivedrab4", 
                  fig_title = "Proportion de PLHIV sous ART (15+)",
                  legend_title = "Couverture ART", 
                  legend_label = scales::percent_format(accuracy = 5L)
)


#-------------------------------------------------------------------------------
# Map: Incidence
# # By lowest area_level
#-------------------------------------------------------------------------------
p6 <- map_outputs(geom_data = data, 
                  var = "incidence",
                  age = "Y015_049", 
                  sex_disag = "both", 
                  start_colour_scale = "#7181910F", 
                  end_colour_scale = "skyblue4", 
                  fig_title = "Taux d'infection par le VIH (15-49)",
                  legend_title = "Incidence pour 1000", 
                  legend_label = scales::label_number(0.1, 1000)
)

grid::grid.draw(cbind(ggplot2::ggplotGrob(p4), ggplot2::ggplotGrob(p5), 
                      ggplot2::ggplotGrob(p6)))

```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}

cat("### **Distribution of HIV by age and sex**")

```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}

cat("### **RÃ©partition du VIH par Ã¢ge et par sexe**")

```

```{r, results = "asis", echo = FALSE, warning = FALSE, message= FALSE}

area_levels <- levels(as.factor(indicators$area_level))

if("0" %in% area_levels){
  area_filter = 0
} else {
  area_filter = min(indicators$area_level)
} 

age_sex <- indicators %>%
  sf::st_drop_geometry() %>%
  dplyr::left_join(outputs$meta_age_group, by = c("age_group", "age_group_label")) %>%
  dplyr::filter(area_level == area_filter,
                calendar_quarter == t2,
                sex != "both",
                age_group_span == 5) %>%
  dplyr::mutate(
           age_group = forcats::fct_reorder(age_group_label, age_group_sort_order)
         )

```

```{r, echo = FALSE, warning = FALSE, message= FALSE, out.width = "75%", fig.height = 3, fig.width = 6, include = print_fr, eval = print_fr}
#-------------------------------------------------------------------------------
# Pop Pyramid: PLHIV (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------

p7 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "plhiv",
                          left_colour = "mistyrose2",
                          right_colour = "red4",
                          x_axis_title = "PVVIH",
                          fig_title = "Personnes vivant avec le VIH", 
                          lang = "fr"
)

#-------------------------------------------------------------------------------
# Pop Pyramid: On ART (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p8 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "art_current_residents",
                          left_colour = "honeydew3",
                          right_colour = "olivedrab4",
                          x_axis_title = "Nombre de personnes sous TARV",
                          fig_title = "RÃ©sidents recevant TARV", 
                          lang = "fr"
)



p8 <- p8 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

#-------------------------------------------------------------------------------
# Pop Pyramid: New Infections
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p9 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "infections",
                          left_colour = "slategray3",
                          right_colour = "skyblue4",
                          x_axis_title = "Infections",
                          fig_title = "Infections annuelles au VIH", 
                          lang = "fr"
)

p9 <- p9 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

# Plot figs together
 grid::grid.draw(cbind(ggplot2::ggplotGrob(p7), ggplot2::ggplotGrob(p8), 
                      ggplot2::ggplotGrob(p9)))

```

```{r, echo = FALSE, warning = FALSE, message= FALSE, out.width = "75%", fig.height = 3, fig.width = 6, include = print_en, eval = print_en}

#-------------------------------------------------------------------------------
# Pop Pyramid: PLHIV (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p7 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "plhiv",
                          left_colour = "mistyrose2",
                          right_colour = "red4",
                          x_axis_title = "PLHIV",
                          fig_title = "People living with HIV"
)

#-------------------------------------------------------------------------------
# Pop Pyramid: On ART (mean)
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p8 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "art_current_residents",
                          left_colour = "honeydew3",
                          right_colour = "olivedrab4",
                          x_axis_title = "Number on ART",
                          fig_title = "Residents receiving ART"
)


p8 <- p8 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

#-------------------------------------------------------------------------------
# Pop Pyramid: New Infections
# # By age and sex (15-49)
#-------------------------------------------------------------------------------
p9 <- pop_pyramid_outputs(disag_data = age_sex,
                          var = "infections",
                          left_colour = "slategray3",
                          right_colour = "skyblue4",
                          x_axis_title = "Infections",
                          fig_title = "Annual HIV infections"
)

p9 <- p9 + ggplot2::theme(
  axis.title.y = ggplot2::element_blank(),
  axis.text.y = ggplot2::element_blank(),
  axis.ticks.y = ggplot2::element_blank()
)

# Plot figs together
grid::grid.draw(cbind(ggplot2::ggplotGrob(p7), ggplot2::ggplotGrob(p8), 
                      ggplot2::ggplotGrob(p9)))

```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}
cat(paste0("### **", area_level_label, "-level HIV trends**"))
```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
cat(paste0("### **Tendances du VIH au niveau ", area_level_label, "**"))
```


```{r, echo = FALSE}
## Dynamicaly size plot based on number of districts

if(district_count <= 35){height <- 8}
if(district_count > 35 && district_count <= 65){height <- 10}
if(district_count > 65 && district_count <= 125){height <- 14}
if(district_count > 125 && district_count <= 160){height <- 20}
if(district_count > 160){height <- 24}

```



  
``` {r, echo=FALSE, warning = FALSE, result = "asis", fig.height = height, fig.width = 10, include = print_en, eval = print_en}  
  
# Check output data for area levels avalible
## If national level data is present, generate figure comparing district level 
## indicator to national level otherwise generate district level figure


if("0" %in% area_levels) {
  
  national <- indicators %>% 
    sf::st_drop_geometry() %>%
    dplyr::filter(area_level == 0,
                  sex == "both",
                  age_group == "Y015_049",
                  calendar_quarter == t2)
  
  gen_est <- function(df, ind, scale, deci, sign) {
    
    df <- df %>% dplyr::filter(indicator == ind) %>%
      dplyr::mutate_if(is.numeric, ~ . * scale) %>%
      dplyr::mutate_if(is.numeric, round, deci) 
    est <- paste0(df$mean, sign, " (", df$lower, " - ", df$upper, sign, ")") }
    
    national_inc <- national[national$indicator == "incidence",]$mean
    national_prev <- national[national$indicator == "prevalence",]$mean
    national_art <- national[national$indicator == "art_coverage",]$mean
    
    national_inc_est <- gen_est(national, "incidence", 1000, 1, "")
    national_prev_est <- gen_est(national, "prevalence", 100, 2, "%")
    national_art_est <- gen_est(national, "art_coverage", 100, 0, "%")
  

  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
  p13 <- national_district_bar_plot(district_data = data, 
                                    var = "prevalence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_prev, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "HIV Prevalence", 
                                    fig_title = "HIV Prevalence (15-49)")
  
  
  p13 <- p13 + ggplot2::scale_fill_manual(name = paste0("National HIV Prevalence: \n ",
                                                        national_prev_est),
                                          values = c("above" = "red4", 
                                                     "below" = "mistyrose2"))
  
  
  
  
  #-------------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending, compared to national indicator
  #--------------------------------------------------------------------------------
  
  p14 <- national_district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    national_indicator = national_art, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "ART coverage", 
                                    fig_title = "Proportion PLHIV on ART (15+)")
  
  
  p14 <- p14 + ggplot2::scale_fill_manual(name = paste0("National ART Coverage:\n ", 
                                                        national_art_est),
                                          values = c("above" = "olivedrab4",
                                                     "below" = "honeydew3"))
   
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
   
  p15 <- national_district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_inc, 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Rate of HIV infection (15-49)", 
                                    fig_title = "HIV Incidence\n per 1000 population")
   
   
  p15 <- p15 + ggplot2::scale_fill_manual(name = paste0("National HIV Incidence\n per 1000 population: ",    
                                                         national_inc_est),
                                               values = c("above" = "skyblue4", 
                                                          "below" = "slategray3")) 
   
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
} else {
  
  # If no national level indicator is present:
  
  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p13 <- district_bar_plot(district_data = data, 
                           var = "prevalence", 
                           age_disag = "Y015_049", 
                           colour = "red4", 
                           label_format = scales::percent_format(1),
                           x_axis_title = "HIV Prevalence", 
                           fig_title = "HIV Prevalence (15-49)")
  
  #-----------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  
  p14 <- district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    colour = "olivedrab4", 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "ART coverage", 
                                    fig_title = "Proportion PLHIV on ART (15+)")
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p15 <- district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    colour = "skyblue4", 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Rate of HIV infection (15-49)", 
                                    fig_title = "HIV Incidence\n per 1000 population")
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
}

```

``` {r, echo=FALSE, warning = FALSE, result = "asis", fig.height = height, fig.width = 10, include = print_fr, eval = print_fr}

# Check output data for area levels avalible
## If national level data is present, generate figure comparing district level 
## indicator to national level otherwise generate district level figure


if("0" %in% area_levels) {
  
  national <- indicators %>% 
    sf::st_drop_geometry() %>%
    dplyr::filter(area_level == 0,
                  sex == "both",
                  age_group == "Y015_049",
                  calendar_quarter == t2)
  
  gen_est <- function(df, ind, scale, deci, sign) {
    
    df <- df %>% dplyr::filter(indicator == ind) %>%
      dplyr::mutate_if(is.numeric, ~ . * scale) %>%
      dplyr::mutate_if(is.numeric, round, deci) 
    est <- paste0(df$mean, sign, " (", df$lower, " - ", df$upper, sign, ")") }
    
    national_inc <- national[national$indicator == "incidence",]$mean
    national_prev <- national[national$indicator == "prevalence",]$mean
    national_art <- national[national$indicator == "art_coverage",]$mean
    
    national_inc_est <- gen_est(national, "incidence", 1000, 1, "")
    national_prev_est <- gen_est(national, "prevalence", 100, 2, "%")
    national_art_est <- gen_est(national, "art_coverage", 100, 0, "%")
  
  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
  p13 <- national_district_bar_plot(district_data = data, 
                                    var = "prevalence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_prev, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "PrÃ©valence du VIH", 
                                    fig_title = "PrÃ©valence du VIH (15-49)", 
                                    lang = "fr")
  
  
  p13 <- p13 + ggplot2::scale_fill_manual(name = paste0("PrÃ©valence nationale du VIH: \n ",
                                                        national_prev_est),
                                          values = c("au-dessus" = "red4", 
                                                     "en dessous" = "mistyrose2"))
  

  #-------------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending, compared to national indicator
  #--------------------------------------------------------------------------------
  
  p14 <- national_district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    national_indicator = national_art, 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "Couverture nationale en matiÃ¨re de TARV", 
                                    fig_title = "Proportion de PLHIV sous ART  (15+)", 
                                    lang = "fr")
  
  
  p14 <- p14 + ggplot2::scale_fill_manual(name = paste0("Couverture nationale en matiÃ¨re de TARV:\n ", 
                                                        national_art_est),
                                          values = c("au-dessus" = "olivedrab4",
                                                     "en dessous" = "honeydew3"))
   
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending, compared to national indicator
  #-----------------------------------------------------------------------------
   
  p15 <- national_district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    national_indicator = national_inc, 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Taux d'infection  par le VIH (15-49)", 
                                    fig_title = "Incidence du VIH\n pour 1000 habitants", 
                                    lang = "fr")
   

   
  p15 <- p15 + ggplot2::scale_fill_manual(name = paste0("Incidence nationale du VIH\n  pour 1000 habitants:\n ",    
                                                         national_inc_est),
                                               values = c("au-dessus" = "skyblue4", 
                                                          "en dessous" = "slategray3")) 
   
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
} else {
  
  # If no national level indicator is present:
  
  #-----------------------------------------------------------------------------
  # Barplot: Preavalence
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p13 <- district_bar_plot(district_data = data, 
                           var = "prevalence", 
                           age_disag = "Y015_049", 
                           colour = "red4", 
                           label_format = scales::percent_format(1),
                                    x_axis_title = "PrÃ©valence du VIH", 
                                    fig_title = "PrÃ©valence du VIH (15-49)")
  
  #-----------------------------------------------------------------------------
  # Barplot: ART coverage
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  
  p14 <- district_bar_plot(district_data = data, 
                                    var = "art_coverage", 
                                    age_disag = "Y015_999", 
                                    colour = "olivedrab4", 
                                    label_format = scales::percent_format(1),
                                    x_axis_title = "Couverture nationale en matiÃ¨re de TARV", 
                                    fig_title = "Proportion de PLHIV sous ART  (15+)")
  
  #-----------------------------------------------------------------------------
  # Barplot: Incidence per 1000
  # # By lowest area_level, descending
  #-----------------------------------------------------------------------------
  p15 <- district_bar_plot(district_data = data, 
                                    var = "incidence", 
                                    age_disag = "Y015_049", 
                                    colour = "skyblue4", 
                                    label_format = scales::label_number(0.01, 1000),
                                    x_axis_title = "Taux d'infection  par le VIH (15-49)", 
                                    fig_title = "Incidence du VIH pour 1000 habitants")
  
  # Plot figs together
  bar_plot <- grid::grid.draw(cbind(ggplot2::ggplotGrob(p13), ggplot2::ggplotGrob(p14),
                        ggplot2::ggplotGrob(p15)))
  
}
  


```

```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}
cat(paste0("### **", area_level_label, "-level indicators**"))
```

```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
cat(paste0("### **Indicateurs de niveau ", area_level_label, "**"))
```

``` {r, echo = FALSE, warning = FALSE, results = 'asis'}


# # Format data for table
percent_indicators <- c("prevalence", "art_coverage")
whole_indicators <- c("plhiv", "infections", "art_current", "art_current_residents")

## Scaling factor
display_scale <- c("prevalence" = 100,
                   "art_coverage" = 100,
                   "incidence" = 1000,
                   "plhiv" = 1,
                   "infections" = 1,
                   "art_current" = 1,
                   "art_current_residents" = 1)
                   
## Number of digits to round by; applied after scaling.
display_digits <- c("prevalence" = 1,
                    "art_coverage" = 1,
                    "incidence" = 1,
                    "plhiv" = -2,
                    "infections" = -1,
                    "art_current" = -2,
                    "art_current_residents" = -2)

display_suffix <- c("prevalence" = "%",
                    "art_coverage" = "%",
                    "incidence" = "",
                    "plhiv" = "",
                    "infections" = "",
                    "art_current" = "",
                    "art_current_residents" = "")

## This controls whether uncertainty range is shown
display_fmt <- c("prevalence" = "%s%s (%s-%s%s)",
                 "art_coverage" = "%s%s (%s-%s%s)",
                 "incidence" = "%s%s (%s-%s%s)",
                 "plhiv" = "%s%s (%s-%s%s)",
                 "infections" = "%s%s (%s-%s%s)",
                 "art_current_residents" = "%s%s (%s-%s%s)",
                 "art_current" = "%s%s")

indicators_15to49 <- c("prevalence", "incidence")
indicators_15plus <- c("art_coverage", "plhiv", "infections",
                       "art_current", "art_current_residents")


x1 <- data %>%
  sf::st_drop_geometry() %>%           
  dplyr::filter(
           sex == "both",
           age_group == "Y015_049" & indicator %in% indicators_15to49 |
           age_group == "Y015_999" & indicator %in% indicators_15plus
         ) %>%
  dplyr::left_join(
           sf::st_drop_geometry(outputs$meta_area) %>%
           dplyr::select(area_id, area_sort_order),
           by = "area_id"
         ) %>%
  dplyr::mutate(area_id = forcats::fct_reorder(area_id, area_sort_order)) %>%
  dplyr::select(area_id, area_name, mean, lower, upper, indicator)

## Format values
format_value <- function(x, indicator) {
  val <- round(x * display_scale[indicator], display_digits[indicator])
  mapply(format, val, trim = TRUE, scientific = FALSE,
         nsmall = pmax(display_digits[indicator], 0), big.mark = ",")
}

x1$mean <- format_value(x1$mean, x1$indicator)
x1$lower <- format_value(x1$lower, x1$indicator)
x1$upper <- format_value(x1$upper, x1$indicator)
x1$suffix <- display_suffix[x1$indicator]
x1$fmt <- display_fmt[x1$indicator]

x1$val <- sprintf(x1$fmt, x1$mean, x1$suffix, x1$lower, x1$upper, x1$suffix)

# Melt data in table 
x4 <- x1 %>% 
  dplyr::select(area_id, area_name, val, indicator) %>%
  tidyr::spread(indicator, val) %>%
  dplyr::select(
           area_name,
           plhiv,
           prevalence,
           infections,
           incidence,
           art_coverage,
           art_current_residents,
           art_current
         )
```

``` {r, echo = FALSE, warning = FALSE, results = 'asis', include = print_en, eval = print_en}
# #-------------------------------------------------------------------------------
# # Table: ART
# # # By lowest area_level, indicators defined above
# #------------------------------------------------------------------------------

x4 %>%
  gt::gt(rowname_col = "area_name") %>%
  gt::tab_stubhead(label = gt::md("**Area**")) %>%
  gt::tab_options(
    table.align = "left",
    heading.align = "centre",
    column_labels.font.size = "small",
    column_labels.background.color = "grey",
    table.font.size = "smaller",
    data_row.padding = gt::px(3),
  ) %>%
  gt::tab_spanner(
    label = gt::md("**Distribution of HIV**"),
    columns = gt::vars('plhiv', 'prevalence')) %>%
  gt::tab_spanner(
    label = gt::md("**Annual HIV infections**"),
    columns = gt::vars('incidence', 'infections')) %>%
  gt::tab_spanner(
    label = gt::md("**Antiretroviral Treatment**"),
    columns = gt::vars('art_coverage', 'art_current_residents', 'art_current')) %>%
  gt::cols_label(
    plhiv = gt::md("**PLHIV 15+**"),
    prevalence = gt::md("**HIV prevalence 15-49**"),
    infections = gt::md("**New infections 15+**"),
    incidence = gt::md("**Incidence 15-49 (per 1000)**"),
    art_coverage = gt::md("**ART coverage 15+**"),
    art_current = gt::md("**Number clients receiving ART 15+**"),
    art_current_residents = gt::md("**Number residents on ART 15+**")
  ) %>%
  gt::cols_align(align = "center") %>%
  gt::cols_width(everything()~ px(155))

```

``` {r, echo = FALSE, warning = FALSE, results = 'asis', include = print_fr, eval = print_fr}
# #-------------------------------------------------------------------------------
# # Table: ART
# # # By lowest area_level, indicators defined above
# #------------------------------------------------------------------------------

x4 %>%
  gt::gt(rowname_col = "area_name") %>%
  gt::tab_stubhead(label = gt::md("**Area**")) %>%
  gt::tab_options(
    table.align = "left",
    heading.align = "centre",
    column_labels.font.size = "small",
    column_labels.background.color = "grey",
    table.font.size = "smaller",
    data_row.padding = gt::px(3),
  ) %>%
  gt::tab_spanner(
    label = gt::md("**RÃ©partition du VIH**"),
    columns = gt::vars('plhiv', 'prevalence')) %>%
  gt::tab_spanner(
    label = gt::md("**Infections annuelles au VIH**"),
    columns = gt::vars('incidence', 'infections')) %>%
  gt::tab_spanner(
    label = gt::md("**ThÃ©rapie AntirÃ©trovirale**"),
    columns = gt::vars('art_coverage', 'art_current_residents', 'art_current')) %>%
  gt::cols_label(
    plhiv = gt::md("**PVVIH 15+**"),
    prevalence = gt::md("**PrÃ©valence du VIH 15-49**"),
    infections = gt::md("**Nouvelles Infections 15+**"),
    incidence = gt::md("**Incidence 15-49 (pour 1000)**"),
    art_coverage = gt::md("**Couverture TARV 15+**"),
    art_current = gt::md("**Nombre de clients recevant TARV 15+**"),
    art_current_residents = gt::md("**Nombre de rÃ©sidents recevant TARV 15+**")
  ) %>%
  gt::cols_align(align = "center") %>%
  gt::cols_width(everything()~ px(155))

```

::: {#translate lang="en"}
### Methods
[Naomi](https://github.com/mrc-ide/naomi) is a small-area estimation model for estimating HIV prevalence and PLHIV, ART coverage, and new HIV infections at district level by sex and five-year age group. The model combines district-level data about multiple outcomes from several sources in a Bayesian statistical model to produce robust indicators of subnational HIV burden.

The model produces estimates at three time points: the year of the most recent population-based survey, the current period at which the most recent ART and ANC programme data are available, and short-term one-year ahead projections for HIV programme planning purposes. Subnational population estimates by sex and age group are sourced from consensus sources in each country and adjusted to match the populations used within Spectrum by sex and age group.

_Survey data_

Cross-sectional estimates for HIV prevalence, ART coverage, and HIV incidence are produced at the mid-point of the most recent nationally representative household survey. For HIV prevalence, the model is calibrated to survey data about HIV prevalence by subnational level, sex, and five-year age group from the most recent population-based survey (for example [Population HIV Impact Assessment survey](https://phia.icap.columbia.edu/) or [Demographic and Health Survey](https://dhsprogram.com/)). Since the survey sample size in each district is relatively small, routinely reported data about HIV prevalence among pregnant women attending their first antenatal care visit, extracted from the national health information system, are used to improve estimates of the spatial pattern of HIV.

_ART Coverage_

Antiretroviral therapy coverage by district, age, and sex is estimated from household survey data about the presence of antiretroviral biomarkers in HIV-positive survey respondents. Routinely reported antiretroviral therapy coverage among pregnant women prior to first antenatal care visit is used as a covariate for the spatial pattern of antiretroviral therapy coverage. The antiretroviral therapy coverage and HIV prevalence are also calibrated so that total number on antiretroviral therapy matches that report in the Spectrum national file.
:::

::: {#translate lang="fr"}
### MÃ©thodes
[Naomi](https://github.com/mrc-ide/naomi) est un modÃ¨le d'estimation Ã  petite Ã©chelle permettant d'estimer la prÃ©valence du VIH et des PVVIH, la couverture ART et les nouvelles infections par le VIH au niveau du district par sexe et par groupe d'Ã¢ge de cinq ans. Le modÃ¨le combine des donnÃ©es au niveau du district sur des rÃ©sultats multiples provenant de plusieurs sources dans un modÃ¨le statistique bayÃ©sien pour produire des indicateurs robustes de la charge du VIH au niveau sous-national.

Le modÃ¨le produit des estimations Ã  trois moments : l'annÃ©e de l'enquÃªte dÃ©mographique la plus rÃ©cente, la pÃ©riode actuelle Ã  laquelle les donnÃ©es les plus rÃ©centes sur les programmes de traitement antirÃ©troviral et de soins prÃ©natals sont disponibles, et des projections Ã  court terme, un an Ã  l'avance, Ã  des fins de planification des programmes de lutte contre le VIH. Les estimations de la population infranationale par sexe et groupe d'Ã¢ge proviennent de sources consensuelles dans chaque pays et sont ajustÃ©es pour correspondre aux populations utilisÃ©es dans Spectrum par sexe et groupe d'Ã¢ge.

_DonnÃ©es d'enquÃªte_

Les estimations transversales de la prÃ©valence du VIH, de la couverture du traitement antirÃ©troviral et de l'incidence du VIH sont produites Ã  mi-parcours de l'enquÃªte sur les mÃ©nages la plus rÃ©cente et la plus reprÃ©sentative au niveau national. Pour la prÃ©valence du VIH, le modÃ¨le est calibrÃ© Ã  partir des donnÃ©es d'enquÃªte sur la prÃ©valence du VIH par niveau sous-national, par sexe et par groupe d'Ã¢ge de cinq ans de l'enquÃªte la plus rÃ©cente auprÃ¨s de la population (par exemple [l'enquÃªte d'Ã©valuation de l'impact du VIH sur la population](https://phia.icap.columbia.edu/) ou [l'enquÃªte dÃ©mographique et sanitaire](https://dhsprogram.com/)). Ãtant donnÃ© que la taille de l'Ã©chantillon de l'enquÃªte dans chaque district est relativement faible, les donnÃ©es rÃ©guliÃ¨rement communiquÃ©es sur la prÃ©valence du VIH parmi les femmes enceintes qui se rendent Ã  leur premiÃ¨re visite de soins prÃ©natals, extraites du systÃ¨me national d'information sanitaire, sont utilisÃ©es pour amÃ©liorer les estimations de la rÃ©partition spatiale du VIH.

_Couverture TARV_

La couverture de la thÃ©rapie antirÃ©trovirale par district, Ã¢ge et sexe est estimÃ©e Ã  partir des donnÃ©es de l'enquÃªte sur les mÃ©nages concernant la prÃ©sence de biomarqueurs antirÃ©troviraux chez les rÃ©pondants sÃ©ropositifs. La couverture de la thÃ©rapie antirÃ©trovirale signalÃ©e de faÃ§on routiniÃ¨re chez les femmes enceintes avant la premiÃ¨re visite de soins prÃ©natals est utilisÃ©e comme covariable pour le modÃ¨le spatial de la couverture de la thÃ©rapie antirÃ©trovirale. La couverture de la thÃ©rapie antirÃ©trovirale et la prÃ©valence du VIH sont Ã©galement calibrÃ©es de maniÃ¨re Ã  ce que le nombre total de personnes sous thÃ©rapie antirÃ©trovirale corresponde Ã  celui dÃ©clarÃ© dans le fichier national Spectrum.
:::



```{r, echo = FALSE, results = 'asis', include = print_en, eval = print_en}
if("true" %in% include$art_attend) {
  
  cat(paste0("
_ART attendance in neighbouring districts_\n 

A challenge for estimating treatment coverage at district level is that persons may access antiretroviral therapy services in a different district than their residence, for example if facilities are closer or perceived to provide better services. The model allows for a probability that resident people living with HIV access antiretroviral therapy in a neighbouring district. The prior assumption is that the large majority of people living with HIV will access antiretroviral therapy in their district of residence, but this probability can vary based on district data about the number receiving antiretroviral therapy compared to HIV prevalence, antiretroviral therapy coverage and population.
             
             
             "))
}
```


```{r, echo = FALSE, results = 'asis', include = print_fr, eval = print_fr}
if("true" %in% include$art_attend) {
  
  cat(paste0("
_FrÃ©quentation du ART dans les districts voisins_\n 

Un dÃ©fi dans la estimation de la couverture du traitement au niveau du district est que les personnes peuvent accÃ©der les services de thÃ©rapie antirÃ©trovirale dans un district diffÃ©rent de leur rÃ©sidence, par exemple si les Ã©tablissements sont plus proches ou perÃ§us comme offrant de meilleurs services. Le modÃ¨le tient compte de la probabilitÃ© que les rÃ©sidents vivant avec le VIH aient accÃ¨s Ã  une thÃ©rapie antirÃ©trovirale dans un district voisin. L'hypothÃ¨se antÃ©rieure est que la grande majoritÃ© des personnes vivant avec le VIH auront accÃ¨s au traitement antirÃ©troviral dans leur district de rÃ©sidence, mais cette probabilitÃ© peut varier en fonction des donnÃ©es du district concernant le nombre de personnes recevant un traitement antirÃ©troviral par rapport Ã  la prÃ©valence du VIH, Ã  la couverture du traitement antirÃ©troviral et Ã  la population.
             
             
             "))
}
```

::: {#translate lang="en"}
_HIV incidence_

Direct estimates of HIV incidence are not available at subnational levels. While some recent household surveys have measured HIV incidence at the national level based on biomarker measures for recent HIV infections, too few recent infections are observed in any district to make a robust estimate. Therefore, to estimate HIV incidence at the subnational level, the HIV transmission rate from Spectrum estimates is calculated and applied to small area estimates of HIV prevalence and ART coverage in each subnational area.  The sex and age distribution in each subnational area are based on HIV incidence rate ratios from Spectrum applied to the population structure in each area.

_Current estimates and one-year ahead projection_

The update estimates from the most recent household survey to the current period, the model conducts a one-step projection of the population the most recent survey to the current period. Population estimates are updated with official population estimates. The number of PLHIV is projected forward based on survival estimates by province, sex, and age group from Spectrum over the same period (which accounts for HIV disease progression and effects of ART scale up on reducing AIDS mortality). ART coverage is updated based on the number currently reported on ART from service provision data.

To extrapolate estimates a further one-year ahead for HIV planning purposes, the number of new infections and PLHIV are calculated based on the transmission rate from national or subnational Spectrum estimates. The number on ART are projected by calculating the increased in odds of ART coverage by age and sex based on ART projections input to Spectrum and applying this change in odds to each subnational area.

_Version_

The Naomi model is supported by UNAIDS and developed and maintained by the [MRC Centre for Global Infectious Disease Analysis](https://www.imperial.ac.uk/mrc-global-infectious-disease-analysis) at Imperial College London. The model receives technical guidance from the [UNAIDS Reference Group on Estimates, Modelling, and Projections](http://epidem.org/). The model was first used in 2020 and continues to be developed responsive to new data and HIV strategic information needs.
:::

::: {#translate lang="fr"}
_Incidence du VIH_

Les estimations directes de l'incidence du VIH ne sont pas disponibles aux niveaux sous-nationaux. Bien que certaines enquÃªtes rÃ©centes auprÃ¨s des mÃ©nages aient mesurÃ© l'incidence du VIH au niveau national sur la base de mesures de biomarqueurs pour les infections rÃ©centes au VIH, trop peu d'infections rÃ©centes sont observÃ©es dans un district quelconque pour faire une estimation robuste. Par consÃ©quent, pour estimer l'incidence du VIH au niveau sous-national, le taux de transmission du VIH Ã  partir des estimations du Spectrum est calculÃ© et appliquÃ© aux estimations de la prÃ©valence du VIH et de la couverture du TAR dans chaque zone sous-nationale.  La rÃ©partition par sexe et par Ã¢ge dans chaque zone infranationale est basÃ©e sur les ratios de taux d'incidence du VIH de Spectrum appliquÃ©s Ã  la structure de la population dans chaque zone.

_Estimations actuelles et projection Ã  un an_

Pour mettre Ã  jour les estimations de l'enquÃªte la plus rÃ©cente auprÃ¨s des mÃ©nages jusqu'Ã  la pÃ©riode actuelle, le modÃ¨le effectue une projection en une Ã©tape de la population de l'enquÃªte la plus rÃ©cente jusqu'Ã  la pÃ©riode actuelle. Les estimations de la population sont mises Ã  jour avec les estimations officielles de la population. Le nombre de PLHIV est projetÃ© vers l'avant sur la base des estimations de survie par province, sexe et groupe d'Ã¢ge de Spectrum sur la mÃªme pÃ©riode (ce qui tient compte de la progression de la maladie du VIH et des effets de l'intensification du ART sur la rÃ©duction de la mortalitÃ© due au SIDA). La couverture du traitement antirÃ©troviral est mise Ã  jour sur la base du nombre de personnes actuellement dÃ©clarÃ©es sous traitement antirÃ©troviral Ã  partir des donnÃ©es sur la prestation de services.

Pour extrapoler les estimations un an Ã  l'avance Ã  des fins de planification de la lutte contre le VIH, le nombre de nouvelles infections et de personnes vivant avec le VIH est calculÃ© sur la base du taux de transmission Ã  partir des estimations nationales ou sous-nationales de Spectrum. Le nombre de personnes sous traitement antirÃ©troviral est projetÃ© en calculant l'augmentation des chances de bÃ©nÃ©ficier d'un traitement antirÃ©troviral par Ã¢ge et par sexe, sur la base des projections relatives au traitement antirÃ©troviral introduites dans Spectrum, et en appliquant cette variation des chances Ã  chaque rÃ©gion infranationale.

_Version_

Le modÃ¨le Naomi est soutenu par l'ONUSIDA et dÃ©veloppÃ© et maintenu par le [MRC Centre for Global Infectious Disease Analysis](https://www.imperial.ac.uk/mrc-global-infectious-disease-analysis) Ã  l'Imperial College London. Le modÃ¨le reÃ§oit des conseils techniques du [Groupe de rÃ©fÃ©rence de l'ONUSIDA sur les estimations, la modÃ©lisation et les projections](http://epidem.org/). Le modÃ¨le a Ã©tÃ© utilisÃ© pour la premiÃ¨re fois en 2020 et continue d'Ãªtre dÃ©veloppÃ© en fonction des nouvelles donnÃ©es et des besoins en informations stratÃ©giques sur le VIH.
:::
